---
title: "Turkey Roost Up/Down Times"
author: "Henry Traynor"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Read in Data}
# March 1-2 2023, ID 11197
require(readr)
df<- read_csv("../Data/11197_2.csv")
```

```{r Acceleration Expansion}
library(dplyr)
#change name of columns
df<-df%>% rename(ID =`individual-local-identifier`, accel=`eobs:accelerations-raw`)

# Function to split 'accel' column into groups of three values (x, y, z axes)
split_accel_data <- function(accel_col) {
  accel_values <- unlist(strsplit(accel_col, " "))
  matrix(accel_values, ncol = 3, byrow = TRUE)
}

# Initialize an empty dataframe to store the expanded data
expanded_df <- data.frame()

# Iterate through each row in the dataframe
for (i in 1:nrow(df)) {
  # Split accel column into x, y, z values
  accel_matrix <- split_accel_data(df$accel[i])
  
  # Create a temporary dataframe for the current row, repeating the timestamp, date, year, and tag-local-identifier for each sample
  temp_df <- data.frame(
    Time = rep(df$Time[i], nrow(accel_matrix)),
    Date = rep(df$Date[i], nrow(accel_matrix)),
    Year = rep(df$Year[i], nrow(accel_matrix)),
    ID = rep(df$ID[i], nrow(accel_matrix)),
    sample_num = 1:nrow(accel_matrix),  # Add a sample number for each sample
    x_axis = accel_matrix[, 1],
    y_axis = accel_matrix[, 2],
    z_axis = accel_matrix[, 3]
  )
  
  # Append the temporary dataframe to the expanded dataframe
  expanded_df <- rbind(expanded_df, temp_df)
}
expanded_df$x_axis=as.numeric(expanded_df$x_axis)
expanded_df$y_axis=as.numeric(expanded_df$y_axis)
expanded_df$z_axis=as.numeric(expanded_df$z_axis)
```

```{r VeDBA Calculation}
#Rename expanded_df
df <- expanded_df
library(zoo)
library(plyr)
library(data.table)
library(dplyr)
library(lubridate)
library(ggplot2)
#Calculate rolling mean of acc for DBA calculation
window_length=40
df$x_mean=append(rollmean(expanded_df$x_axis, window_length, align="left"), replicate(window_length-1, NA))
df$y_mean=append(rollmean(expanded_df$y_axis, window_length, align="left"), replicate(window_length-1, NA))
df$z_mean=append(rollmean(expanded_df$z_axis, window_length, align="left"), replicate(window_length-1, NA))

#Calculate dynamic body acceleration (DBA) by row for each x,y,and z measurement 
df$ax=df$x_axis-df$x_mean
df$ay=df$y_axis-df$y_mean
df$az=df$z_axis-df$z_mean

#Add up all the absolute values of DBA to get OBDA for each row 
df$odba=(abs(df$ax)+abs(df$ay)+abs(df$az)) 

# Calculate VeDBA by row
df$VeDBA=sqrt(df$ax^2+df$ay^2+df$az^2)

#Calculate log of average VeDBA for each burst
calculate_rolling_average <- function(column, window_size = 40) {
  sapply(seq_along(column), function(i) {
    start <- floor((i - 1) / window_size) * window_size + 1
    end <- min(start + window_size - 1, length(column))
    mean(column[start:end])
  })
}

df=df%>%
  mutate(AVG_VeDBA=calculate_rolling_average(VeDBA))

df$log_avg_VeDBA=log(df$AVG_VeDBA)

#Concatenate Times
df$DateTime = paste(df$Date, df$Time)
df$dt = mdy_hms(df$DateTime, tz="GMT")
df$dt = df$dt - hours(5)

#Calculate rolling median of the log VeDBA for 10 minute window
calculate_rolling_median <- function(column, window_size = 400) {
  sapply(seq_along(column), function(i) {
    start <- floor((i - 1) / window_size) * window_size + 1
    end <- min(start + window_size - 1, length(column))
    median(column[start:end])
  })
}

df=df%>%
  mutate(median_VeDBA=calculate_rolling_median(log_avg_VeDBA))

#plot(df$dt, df$median_VeDBA)

#Calculate rolling median of the avg VeDBA for 6 minute window
df=df%>%
  mutate(median_VeDBA=calculate_rolling_median(AVG_VeDBA))
```

```{r Averaging Raw Values}
#Pull out raw values and average over each recorded burst
df.raw <- data.frame(
  ID = df$ID,
  x_axis = df$x_axis,
  y_axis = df$y_axis,
  z_axis = df$z_axis,
  dt = df$dt
)

condense_burst <- function(column, window_size = 40) {
  sapply(seq_along(column), function(i) {
    start <- floor((i - 1) / window_size) * window_size + 1
    end <- min(start + window_size - 1, length(column))
    mean(column[start:end])
  })
}

df.raw=df.raw%>%
  mutate(x_avg=condense_burst(x_axis))
df.raw=df.raw%>%
  mutate(y_avg=condense_burst(y_axis))
df.raw=df.raw%>%
  mutate(z_avg=condense_burst(z_axis))

df.raw <- df.raw %>% distinct(dt, .keep_all=TRUE)
df.avg <- df.raw %>%
  select("ID", "dt", "x_avg", "y_avg", "z_avg")

ggplot(data=df.avg, aes(x=dt, y=z_avg)) + geom_line()
ggplot(data=df.raw, aes(x=dt, y=z_avg)) + geom_line()
```

```{r Rolling Interval Statistics}
library(zoo)
library(moments)

intervalAnalysis <- function(df.sample, fun.call, dataCol, windowLength, windowStep) {
  colNum = which(colnames(df.sample)==dataCol)
  #calculation of statistic values
  stat <- rollapply(df.sample[,colNum],
                      FUN=fun.call,
                      width=windowLength,
                      by=windowStep,
                      by.column = TRUE,
                      align = "center")
  
  timestamp <- seq(from=df.sample$dt[1], to=df.sample$dt[nrow(df.sample)-windowLength], length.out=length(stat))
  #combining stat values with time indices
  df.stat <- data.frame(timestamp,stat)
  
  return(df.stat)
}

library(goeveg)
library(ggplot2)

stats <- c("cv",
           "mean",
           "sd")

timeParms <- c(window=20, step=1)

statsList <- list()
for(stat in stats) {
  statsList = append(statsList, list(intervalAnalysis(df.avg, stat, "z_avg", timeParms[1], timeParms[2])))
}

statsPlot <- list()
for(i in 1:length(statsList)) {
  p <- ggplot(data=statsList[[i]], aes(x=timestamp, y=stat)) + geom_line() + ylab(stats[i]) + xlab("Time")
  statsPlot <- append(statsPlot, list(p))
}

library(ggpubr)
ggarrange(statsPlot[[1]],
          statsPlot[[2]],
          statsPlot[[3]])

statsPlot[[2]]
```

```{r Avg Slope Interval}
avgSlope <- function(x) {
  return((x[length(x)] - x[1]) / length(x))
}

df_smooth_avg <- statsList[[2]]
colnames(df_smooth_avg) <- c("dt", "stat")

avg_slope <- intervalAnalysis(df.avg,
                              avgSlope,
                              "z_avg",
                              windowLength=15, 
                              windowStep=2)

colnames(avg_slope) <- c("dt", "stat")

ggplot(data=avg_slope, aes(x=dt,y=stat)) +geom_line()

var_avg_slope <- intervalAnalysis(avg_slope,
                             var,
                             "stat",
                             windowLength=10,
                             windowStep=1)

ggplot(data=var_avg_slope, aes(x=timestamp, y=stat)) + geom_line() + ylab("Variance of Average Slope") + xlab("Time") +
  geom_hline(yintercept=7, color="red")

colnames(var_avg_slope) <- c("dt", "stat")

```


```{r Thresholds}
library(dplyr)

c <-  6.0 #medianCalc(var_avg_slope$stat,propDaylight1)  #threshold value (critical value)

colnames(var_avg_slope) <- c("dt", "stat")

temp <- var_avg_slope %>% mutate(across(dt, ~ as.Date(., format("%m/%d/%Y"), tz="GMT")))
var_avg_slope$day <- temp$dt

var_avg_slope$distC <- var_avg_slope$stat-c

day1 <- var_avg_slope[var_avg_slope$day=="2023-03-01",]
day2 <- var_avg_slope[var_avg_slope$day=="2023-03-02",]

zero_dist1 <- vector("numeric")
zero_dist2 <- vector("numeric")

for(i in 1:(length(day1$distC)-1)) {
  if(day1$distC[i]<0 & day1$distC[i+1]>0) {
    zero_dist1 <- rbind(zero_dist1, c(i))
  }
  if(day1$distC[i]>0 & day1$distC[i+1]<0) {
    zero_dist1 <- rbind(zero_dist1, c(i))
  }
}

for(i in 1:(length(day2$distC)-1)) {
  if(day2$distC[i]<0 & day2$distC[i+1]>0) {
    zero_dist2 <- rbind(zero_dist2, c(i))
  }
  if(day2$distC[i]>0 & day2$distC[i+1]<0) {
    zero_dist2 <- rbind(zero_dist2, c(i))
  }
}

day1$dt[zero_dist1[1]]
day1$dt[zero_dist1[length(zero_dist1)]]

day2$dt[zero_dist2[2]]
day2$dt[zero_dist2[length(zero_dist2)]]

ggplot(data=var_avg_slope, aes(x=dt, y=stat)) + geom_line() + ylab("SD Average Slope") + xlab("Time") +
  geom_vline(xintercept=day1$dt[zero_dist1[1]],color="blue") +
  geom_vline(xintercept=day1$dt[zero_dist1[length(zero_dist1)]],color="blue") +
  geom_vline(xintercept=day2$dt[zero_dist2[2]],color="blue") +
  geom_vline(xintercept=day2$dt[zero_dist2[length(zero_dist2)]],color="blue") +
  geom_hline(yintercept = c, color="red", linetype="dashed")
  

```
